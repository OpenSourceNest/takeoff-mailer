use futures_util::stream::StreamExt;
use lapin::{
    BasicProperties, Connection, ConnectionProperties,
    options::{
        BasicAckOptions, BasicConsumeOptions, BasicPublishOptions, BasicQosOptions,
        BasicRejectOptions, QueueDeclareOptions,
    },
    types::FieldTable,
};
use prost::Message;
use std::error::Error;

mod config;
mod mail;
mod template;

// Include the code generated by build.rs from the .proto file
pub mod email_system {
    include!(concat!(env!("OUT_DIR"), "/email_system.rs"));
}

use email_system::EmailTask;
const QUEUE_NAME: &str = "email_queue";

#[tokio::main]
async fn main() -> Result<(), Box<dyn Error>> {
    let config = config::Config::from_env();

    println!("Connecting to: {}", config.rabbitmq_url);

    let rabbit_connection =
        match Connection::connect(&config.rabbitmq_url, ConnectionProperties::default()).await {
            Ok(c) => c,

            Err(e) => {
                eprintln!("[CRITICAL] Failed to connect to RabbitMQ: {}", e);
                panic!("Cannot proceed without RabbitMQ connection");
            }
        };

    let channel = match rabbit_connection.create_channel().await {
        Ok(c) => c,

        Err(e) => {
            eprintln!("[CRITICAL] Failed to create channel: {}", e);
            panic!("Cannot proceed without RabbitMQ channel");
        }
    };

    println!("[SYSTEM] Connected to RabbitMQ. Awaiting tasks...");

    if let Err(e) = channel
        .queue_declare(
            &QUEUE_NAME,
            QueueDeclareOptions {
                durable: true,
                ..QueueDeclareOptions::default()
            },
            FieldTable::default(),
        )
        .await
    {
        eprintln!("[CRITICAL] Failed to declare queue: {}", e);
        panic!("Cannot proceed without RabbitMQ queue");
    };

    if let Err(e) = channel.basic_qos(10, BasicQosOptions::default()).await {
        eprintln!("[CRITICAL] Failed to set QoS: {}", e);
        panic!("Cannot proceed without RabbitMQ QoS");
    };

    let mut consumer = match channel
        .basic_consume(
            &QUEUE_NAME,
            "rust_worker",
            BasicConsumeOptions::default(),
            FieldTable::default(),
        )
        .await
    {
        Ok(c) => c,

        Err(e) => {
            eprintln!("[CRITICAL] Failed to start consumer: {}", e);
            panic!("Cannot proceed without RabbitMQ consumer");
        }
    };

    while let Some(delivery) = consumer.next().await {
        let delivery = delivery.expect("Error in consumer stream");

        match EmailTask::decode(&*delivery.data) {
            Ok(mut task) => {
                println!("[TASK] Processing email to: {}", task.to);

                match mail::send_email_logic(&config, &task).await {
                    Ok(_) => {
                        println!("[SUCCESS] Email delivered.");
                        delivery.ack(BasicAckOptions::default()).await?;
                    }

                    Err(e) => {
                        eprintln!("[ERROR] Send failed: {}. Retrying...", e);

                        if let Err(e) = handle_retry(&channel, &mut task, delivery).await {
                            eprintln!("[CRITICAL] Retry handling failed: {}", e)
                        }
                    }
                }
            }

            Err(e) => {
                eprintln!("[CRITICAL] Could not decode Protobuf: {:?}", e);

                if let Err(e) = delivery.reject(BasicRejectOptions { requeue: false }).await {
                    eprintln!("[CRITICAL] Failed to reject message: {}", e);
                }
            }
        }
    }

    Ok(())
}

async fn handle_retry(
    channel: &lapin::Channel,
    task: &mut EmailTask,
    delivery: lapin::message::Delivery,
) -> Result<(), Box<dyn Error>> {
    if task.retry_count < 3 {
        task.retry_count += 1;

        // Re-encode the updated task with the new retry count
        let mut buf = Vec::new();
        match task.encode(&mut buf) {
            Ok(_) => (),

            Err(e) => {
                eprintln!("[CRITICAL] Failed to encode Protobuf for retry: {:?}", e);
                return Err(Box::new(e));
            }
        }

        // Send back to the queue
        if let Err(e) = channel
            .basic_publish(
                "",
                &QUEUE_NAME,
                BasicPublishOptions::default(),
                &buf,
                BasicProperties::default(),
            )
            .await
        {
            eprintln!("[CRITICAL] Failed to re-publish message for retry: {}", e);
            // TODO - return Err(Box::<dyn Error>::from_raw(e));
        };

        println!("[RETRY] Re-queued task. Attempt: {}", task.retry_count);
    } else {
        println!("[DROP] Max retries reached for {}", task.to);
    }

    // Acknowledge the old message so it's removed; we've already handled the "retry" via publish
    delivery.ack(BasicAckOptions::default()).await?;

    Ok(())
}
